#ifndef CONST_STRINGS_H
#define CONST_STRINGS_H

// cs - сокращение от const string
// через макроподстановку, потому что это DSL, который требуется только локально в этом файле
#define cs_ const char * const

cs_ LATEX_BEGIN = "\\documentclass[12pt]{article}\n"
                  "\\usepackage{fontspec}\n"
                  "\\usepackage{polyglossia}\n"
                  "\\setmainlanguage{russian}\n"
                  "\\setotherlanguage{english}\n"
                  "\\defaultfontfeatures{Ligatures=TeX,Renderer=HarfBuzz}\n"
                  "\\setmainfont{PlayfairDisplay-Regular}[Path=fonts/,Extension=.ttf,BoldFont=PlayfairDisplay-Bold,ItalicFont=PlayfairDisplay-Italic,BoldItalicFont=PlayfairDisplay-BoldItalic]\n"
                  "\\setsansfont{PlayfairDisplay-Regular}[Path=fonts/,Extension=.ttf,BoldFont=PlayfairDisplay-Bold,ItalicFont=PlayfairDisplay-Italic,BoldItalicFont=PlayfairDisplay-BoldItalic]\n"
                  "\\setmonofont{PlayfairDisplay-Regular}[Path=fonts/,Extension=.ttf,BoldFont=PlayfairDisplay-Bold,ItalicFont=PlayfairDisplay-Italic,BoldItalicFont=PlayfairDisplay-BoldItalic]\n"
                  "\\newfontfamily\\cyrillicfont{PlayfairDisplay-Regular}[Path=fonts/,Extension=.ttf,BoldFont=PlayfairDisplay-Bold,ItalicFont=PlayfairDisplay-Italic,BoldItalicFont=PlayfairDisplay-BoldItalic,Script=Cyrillic]\n"
                  "\\newfontfamily\\cyrillicfontsf{PlayfairDisplay-Regular}[Path=fonts/,Extension=.ttf,BoldFont=PlayfairDisplay-Bold,ItalicFont=PlayfairDisplay-Italic,BoldItalicFont=PlayfairDisplay-BoldItalic,Script=Cyrillic]\n"
                  "\\newfontfamily\\cyrillicfonttt{PlayfairDisplay-Regular}[Path=fonts/,Extension=.ttf,BoldFont=PlayfairDisplay-Bold,ItalicFont=PlayfairDisplay-Italic,BoldItalicFont=PlayfairDisplay-BoldItalic,Script=Cyrillic]\n"
                  "\\usepackage{amsmath,amssymb}\n"
                  "\\usepackage{breqn}\n"
                  "\\usepackage{graphicx}\n"
                  "\\allowdisplaybreaks\n"
                  "\\begin{document}\n\n"
                  "\\section{Введение}\n"
                  "%s\n\n"
                  "\\bigskip\\hrule\\bigskip\n";

cs_ INTRO_STR =
"Привет, Хабр! Сегодня поговорим о том, о чём не принято говорить в приличном обществе backend-разработчиков — "
"о математическом анализе. Конкретнее — о взятии производных.«Зачем мне это в 2025 году?» — спросите вы. "
"И это отличный вопрос. Но если вы когда-нибудь открывали статью про машинное обучение и видели там градиентный "
"спуск — поздравляю, вы уже знаете зачем. Просто не хотите признавать. "
"В этой статье мы разберём дифференцирование по шагам: от простого к сложному, от константы к композиции функций. "
"Я постараюсь объяснить всё так, чтобы было понятно даже тем, кто последний раз видел производную на экзамене — и "
"сразу после этого успешно её забыл. Под катом — правила дифференцирования, примеры и лёгкая ностальгия по временам, "
"когда главной проблемой было не «почему прод упал», а «почему не сходится ряд».";

cs_ CONCLUSION_STR =
"Готово. Если вам показалось, что это было легко — значит, я хорошо написал статью. "
"Если сложно — значит, вы внимательно читали.";

cs_ START_STR[] = {
    "Итак, перед нами функция, которую нужно продифференцировать. Выглядит невинно. Пока что."
  , "Дано следующее выражение. Глубоко вдохните — и поехали."
  , "Рассмотрим функцию, производную которой нам предстоит найти. Спойлер: она будет длиннее."
  , "На входе имеем это. На выходе хотим производную. Между ними — немного магии и много правил."
  , "Задача: найти производную следующего выражения. Решение: подгоним ответ."
  , "Перед вами функция. Красивая, компактная. Наслаждайтесь, пока можете."
  , "Исходное выражение выглядит так. После дифференцирования оно будет выглядеть... иначе."
  , "Что ж, давайте разберём эту функцию на производные. В буквальном смысле."
  , "Наша сегодняшняя жертва — вот это выражение. Приступим."
  , "Функция задана. Дифференцирование неизбежно."
  , "Вот что нам нужно продифференцировать. Кофе рекомендуется."
  , "Начнём с простого — посмотрим на исходную функцию. Дальше будет сложнее."
  , "Имеется выражение. Требуется: производная. Поехали."
  , "Представляю вашему вниманию функцию, которая сейчас будет разобрана по косточкам."
  , "Ниже — выражение, с которым мы сейчас будем работать. Морально подготовьтесь."
};

cs_ RESULT_STR[] = {
    "В итоге получаем выражение, которое выглядит сложнее исходного. Но мы-то знаем, что это производная."
  , "Вот и всё. Производная найдена. Можно выдохнуть."
  , "Результат получен. Да, он длиннее исходного выражения. Нет, это не баг."
  , "Финальный ответ. Выглядит устрашающе, но математически корректно."
  , "Производная вычислена. Если хотите проверить — Wolfram Alpha вам в помощь."
  , "Готово. Теперь вы знаете производную этой функции. Используйте эту силу мудро."
  , "Вот что получилось. Красота — в глазах смотрящего. Математика — в формулах."
  , "Дифференцирование завершено. Выражение выше — ваш ответ."
  , "Производная найдена успешно. Никто не пострадал (надеюсь)."
  , "Вот она — производная во всей красе. Любуйтесь."
  , "Миссия выполнена. Производная доставлена."
  , "Итого имеем следующий результат. Да, это всё одно выражение."
  , "Готово! Если результат кажется сложным — так и есть. Но он правильный (насколько могу судить)."
  , "Финиш. Производная посчитана. Статью можно закрывать. Или читать дальше, если интересно."
};

cs_ STEPS_STR[] = {
    "Применим правило, которое вы наверняка помните ещё со школы. Ну, или не помните — тогда просто поверьте на слова."
  , "Как говорится в документации к математическому анализу, производная суммы равна сумме производных. Кто бы мог подумать."
  , "А вот здесь начинается магия. Точнее, правила дифференцирования. Но магия звучит лучше."
  , "Дифференцируем. Те, кто писал production-код в 3 часа ночи, поймут, остальным соболезную."
  , "Следующий шаг тривиален и оставляется читателю в качестве нетрудного домашнего упражнения. Шучу, вот он:"
  , "Если вы дочитали до этого места — поздравляю, вы либо проверяющий, либо действительно любите математику."
  , "Применяем chain rule. Да, тот самый, который все забывают на экзамене."
  , "Это, конечно, можно было решить через автодифференцирование. Но где в этом веселье?"
  , "UPD: в комментариях подсказывают, что это можно сделать проще. Но мы пойдём своим путём."
  , "Дальше будет немного больно. Но мы справимся."
  , "Если на этом месте вы потерялись — не переживайте, автор тоже."
  , "Переходим к следующему шагу. Те, кто ещё с нами — вы молодцы."
  , "Математика не спрашивает, готовы ли вы. Она просто происходит."
  , "Классика жанра. Этот паттерн вы будете видеть ещё много раз."
  , "Спойлер: дальше будет ещё одна производная. И ещё. И ещё."
  , "На этом месте обычно кто-то спрашивает: «А можно было по-другому?» Можно. Но мы уже здесь."
  , "Если вам кажется, что это очевидно — поздравляю, вы разобрались в теме."
  , "Секундочку, сейчас будет магия... А это просто правила дифференцирования."
  , "Запомните эту комбинацию. Она будет сниться вам по ночам. Особенно если вы студент, особенно если 1 курса."
};

cs_ COMPLEX_FUNC_STR[] = {
    "Берём производную сложной функции. Сложной не потому что трудно, а потому что вложенность."
  , "	Применяем chain rule. Да, тот самый, который все забывают на экзамене."
  , "Производная сложной функции: берём внешнюю, потом умножаем на производную внутренней. Рекурсия в чистом виде."
  , "f(g(x))' = f'(g(x)) * g'(x). Если эта формула вызывает у вас флешбэки с первого курса — это нормально."
  , "Вложенная функция? Значит, цепное правило. Всё как в жизни: чем глубже копаешь, тем сложнее."
  , "Не забываем про внутреннюю производную. Эту ошибку совершают все. Абсолютно все."
  , "Chain rule — главный босс дифференцирования. Встречается на каждом шагу."
  , "Дифференцируем снаружи внутрь. Как чистка лука, только с формулами."
  , "Умножаем на производную аргумента. Это не опечатка, это правило."
  , "Композиция функций. Здесь начинается настоящее веселье."
  , "Правило цепочки. Одно звено тянет за собой другое — и так до самого x."
  , "Внешняя функция дифференцируется, внутренняя — подставляется и тоже дифференцируется. Матрёшка от мира математики."
  , "Если вам показалось, что мы уже это делали — вам не показалось. Chain rule вызывается рекурсивно."
  , "И снова производная сложной функции. Говорил же — на каждом шагу."
  , "f'(g(x)) * g'(x). Запомните эту комбинацию. Она будет сниться вам по ночам. Особенно если вы студент, особенно если 1 курса."
  , "Разворачиваем вложенность. Каждый уровень — новый множитель к производной."
  , "Сложная функция - как подземелье в мире математики. Нужно пройти все уровни чтобы выйти."
};

cs_ ADD_FUNC_STR[] = {
    "Производная суммы — сумма производных. Одно из немногих правил, которое реально интуитивно понятно."
  , "Производная суммы — сумма производных. Если бы в математике было всегда так просто."
  , "Складываем? Дифференцируем по частям. Всё честно."
  , "Линейность в чистом виде. Математики такое любят, а особенно студенты."
};

cs_ SUB_FUNC_STR[] = {
    "Вычитание — это просто сложение с плохим настроением. Правило то же."
  , "Минус никуда не денется. Он просто перейдёт в производную."
  , "Разность. Дифференцируем каждое слагаемое, знаки сохраняем."
  , "Минус почти как плюс, только он отрицательный."
};

cs_ MUL_FUNC_STR[] = {
    "Правило Лейбница. Нет, не то, которое про печеньки."
  , "Производная произведения ≠ произведение производных. Классическая ловушка."
  , "u'v + uv'. Запомните это, как пароль от рабочей почты, что вы его не знаете!?"
};

cs_ DIV_FUNC_STR[] = {
    "Производная частного. Держитесь, сейчас будет формула."
  , "(u'v - uv') / v^2. Если забыли — не стыдно, все забывают."
  , "Деление. Тут главное не перепутать, что от чего отнимать."
  , "Такое нужно знать. Ну, или быстро гуглить."
};

cs_ POW_FUNC_STR[] = {
    "Степенная функция. n*x^(n-1) — и никакой магии."
  , "Показатель степени спускается вниз, а сам уменьшается на единицу. Как в жизни."
  , "x^n -> n*x^(n-1). Это правило нужно знать, как таблицу умножения. Ну, или загуглить."
};

cs_ LOG_FUNC_STR[] = {
    "Логарифм с основанием a. Не забываем про ln(a) в знаменателе."
  , "1 / (x * ln(a)). Да, основание влияет. Нет, это не баг."
  , "Логарифмируем и дифференцируем. Звучит как название курса."
};

cs_ LN_FUNC_STR[] = {
    "Натуральный логарифм — любимчик математиков. Производная: 1/x. Просто и красиво."
  , "ln(x) -> 1/x. Пожалуй, одна из самых элегантных производных."
  , "Число e не просто так называют «естественным». Вот вам доказательство."
};

cs_ SIN_FUNC_STR[] = {
    "Синус превращается в косинус. Тригонометрический сюжетный твист."
  , "(sin x)' = cos x. Классика. Как «Hello, World!», только в матанализе."
  , "Производная синуса. Если вы это забыли — пора обновить кэш."
};

cs_ COS_FUNC_STR[] = {
    "Косинус превращается в минус синус. Да, минус. Не забудьте."
  , "cos -> -sin. Этот минус потерял больше баллов на экзаменах, чем любая другая ошибка."
  , "Внимание: знак меняется. Это не баг, это фича тригонометрии."
};

cs_ TAN_FUNC_STR[] = {
    "Тангенс. Производная: 1/cos^2(x). Или sec^2(x), если вы из тех, кто знает, что такое секанс."
  , "tan -> 1/cos^2. Тригонометрия усложняется. Держитесь."
  , "Производная тангенса. Гуглится чаще, чем хотелось бы признавать."
};

cs_ CTG_FUNC_STR[] = {
    "Котангенс -> -1/sin^2(x). Минус на месте, всё по плану."
  , "ctg -> -csc^2. Если вы помните, что такое косеканс — респект."
  , "Производная котангенса. Редкий зверь, но иногда встречается."
};

cs_ ASIN_FUNC_STR[] = {
    "Обратный синус. Производная с корнем в знаменателе. Готовьтесь."
  , "arcsin -> 1/sqrt(1-x^2). Выглядит страшно, работает стабильно."
  , "Арксинус. Тот случай, когда производная сложнее исходной функции."
};

cs_ ACOS_FUNC_STR[] = {
    "Арккосинус — это арксинус, но с другим знаком. Математики любят такие шутки."
  , "arccos -> -1/sqrt(1-x^2). Отличается от арксинуса только минусом. Внимательнее."
  , "Производная арккосинуса. Спойлер: почти как у арксинуса, но не совсем."
};

cs_ ATAN_FUNC_STR[] = {
    "arctg -> 1/(1+x^2). Одна из самых приятных обратных тригонометрических функций."
  , "Арктангенс. Производная без корней — уже праздник."
  , "1/(1+x^2). Простота, которую мы заслужили после арксинуса."
};

cs_ ACTG_FUNC_STR[] = {
    "arcctg -> -1/(1+x^2). Как арктангенс, но с экзистенциальным минусом."
  , "Арккотангенс. Встречается редко, но метко."
  , "Минус от арктангенса. Паттерн прослеживается, да?"
};

cs_ SQRT_FUNC_STR[] = {
    "sqrt(x) — это x^(1/2). А значит, производная: 1/(2*sqrt(x)). Степени наше всё.",
    "Корень извлекли, теперь дифференцируем. 1/(2*sqrt(x)) — и готово.",
    "Квадратный корень. Просто степень 1/2 в маскировке.",
    "SQRT - это почти как лучший футбольный клуб МФТИ: SqvRT.",
};

cs_ SINH_FUNC_STR[] = {
    "sh(x) -> ch(x). Гиперболические функции — как обычные, только без минусов-сюрпризов."
  , "Гиперболический синус. Производная — гиперболический косинус. Всё логично."
  , "sinh -> cosh. Тригонометрия, но в параллельной вселенной."
};

cs_ COSH_FUNC_STR[] = {
    "ch(x) -> sh(x). Без минуса! Вот за это мы и любим гиперболические функции."
  , "cosh -> sinh. Заметьте: никаких подвохов со знаком."
  , "Гиперболический косинус — более дружелюбная версия обычного."
};

cs_ TANH_FUNC_STR[] = {
    "th(x) -> 1/ch^2(x). Если вы работаете с нейросетями — эта функция вам знакома."
  , "tanh -> sech^2. Активация RNN одобряет."
  , "Гиперболический тангенс. Любимец deep learning и производных."
};

cs_ CTH_FUNC_STR[] = {
    "cth(x) -> -1/sh^2(x). Минус вернулся. Скучали?"
  , "Гиперболический котангенс. Редкий гость, но формулу знать полезно."
  , "cth -> -csch^2. Если вы дошли до этой функции — вы точно не сдаётесь."
};

cs_ SIMPLIFY_FOLD_CONST_STR[] = {
    "Оптимизируем. Нет, не O(n), а просто убираем лишние нули."
  , "Умножение на единицу — как legacy-код: вроде ничего не делает, но убрать страшно. Мы уберём."
  , "x + 0 = x. Казалось бы, очевидно. Но компилятор сам не догадается."
  , "Рефакторим выражение. Чистый код — чистая совесть."
  , "Применяем алгебраические преобразования. Звучит солидно, а по факту — просто убираем мусор."
  , "После этой оптимизации выражение стало читаемым. Почти как после code review."
  , "0 * (что угодно) = 0. Иногда математика бывает милосердна."
  , "Упрощаем. Если бы всё в жизни упрощалось так легко..."
  , "Удаляем мёртвый код. В смысле, мёртвые слагаемые."
  , "Можно было бы оставить как есть. Но мы же профессионалы."
  , "Этот шаг оптимизации сэкономит вам... ну, пару символов."
  , "Если бы выражения проходили code review — это бы не прошло. Исправляем."
  , "Причёсываем результат. Первое впечатление важно."
  , "Было громоздко — стало элегантно. Почти как рефакторинг legacy."
  , "Убираем визуальный шум. Минимализм в математике."
  , "Финальный polish. Потому что детали имеют значение."
  , "Применяем DRY-принцип: Don't Repeat Yourself. К нулям тоже относится."
};

cs_ SIMPLIFY_NETRAL_STR[] = {
    "Рефакторим выражение. Чистый код — чистая совесть."
  , "Применяем алгебраические преобразования. Звучит солидно, а по факту — просто убираем мусор."
  , "После этой оптимизации выражение стало читаемым. Почти как после code review."
  , "Упрощаем. Если бы всё в жизни упрощалось так легко..."
  , "Схлопываем тождественное выражение. Это как tree shaking, только для математики."
  , "Можно было бы оставить как есть. Но мы же профессионалы."
  , "Этот шаг оптимизации сэкономит вам... ну, пару символов."
  , "Если бы выражения проходили code review — это бы не прошло. Исправляем."
  , "Причёсываем результат. Первое впечатление важно."
  , "Было громоздко — стало элегантно. Почти как рефакторинг legacy."
  , "Убираем визуальный шум. Минимализм в математике."
  , "Финальный polish. Потому что детали имеют значение."
  , "Применяем DRY-принцип: Don't Repeat Yourself. К нулям тоже относится."
};

#undef cs_

#endif // CONST_STRINGS_H